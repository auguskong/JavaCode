复习:

Bug Free:
======================================
Permutation



debug出来的题:
======================================
Valid Sudoku: rows 是一维的还是多维的？ 如果是一维的存的是当前位置的个数
不能把boolean 声明语句写在列循环 和 cell循环里面 否则每个循环都会新建一个boolean[]没有办法
记录之前的结果
同一个col有重复
[
["8","3",".",".","7",".",".",".","."],
["6",".",".","1","9","5",".",".","."],
[".","9","8",".",".",".",".","6","."],
["8",".",".",".","6",".",".",".","3"],
["4",".",".","8",".","3",".",".","1"],
["7",".",".",".","2",".",".",".","6"],
[".","6",".",".",".",".","2","8","."],
[".",".",".","4","1","9",".",".","5"],
[".",".",".",".","8",".",".","7","9"]
]

同一个cell有重复 不对
[
[".",".",".",".","5",".",".","1","."],
[".","4",".","3",".",".",".",".","."],
[".",".",".",".",".","3",".",".","1"],
["8",".",".",".",".",".",".","2","."],
[".",".","2",".","7",".",".",".","."],
[".","1","5",".",".",".",".",".","."],
[".",".",".",".",".","2",".",".","."],
[".","2",".","9",".",".",".",".","."],
[".",".","4",".",".",".",".",".","."]
]

debug不出来抄答案的题:
=====================================
Restore IP Addresses:
Integer.parseInt() 有取值范围限定
substring(start, end) 也有范围限定 需要先check end end的上限是 == s.length()
限定strIndex for循环的上限 ? 是的 用for(int i = 0; i < 3; i++) 最多只遍历3位
终止条件不能是 sb.length() == s.length() 因为sb里面还有我们自定义添加的 '.'元素 会提前终止

Generate Parentheses:
left-- 和 left-1的区别

Remove Invalid Parentheses:
用balance来保证左括号的数量一定要大于右括号
用currIndex来保证

瞄了一眼答案的题目:
=====================================
Sudoku Solver:
二维数组里面存的是什么？？
rows 第i行 1-9是否存在
cols 第j行 1-9是否存在
blocks 第i个九宫格 1-9是否存在

dfs():
判断是否是出口 index == 81
确定row col block
判断当前位置是否为empty
尝试将1-9的字符分别填到当前empty位置中
    先确定1-9不在当前 行/列/九宫格中存在
        填上char
        dfs(下一个格)
        删除char

===========================================

新题:
290. Word Pattern  HashMap 直接记录对应关系
205（绑定290）. Isomorphic Strings
291. Word Pattern II
bijection:
A function that is both one-to-one and onto.
双射：一对一且映成的函数
必须是1对1的 所以需要一个HashSet来进行去重 要保证
pattern中的字符 c 只对应str中的 某个字符串
str中的字符串 也只能对应pattern中的某个字符


瞄了一眼答案的题目:
Generalized Abbreviation: 双选项(branch)的DFS 对于当前位置的char 分为拿和不拿两种情况,
拿: sb.append(previous count) sb.append(c) dfs(count = 0)
不拿: 直接 dfs(count + 1) 记在abbreviation之中
